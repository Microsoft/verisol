(*Code generated by compiler*)

module Item_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array


noeq type t_item_cel = {
  item_cel_market : address;
  item_cel_sellerId : address;
  item_cel_price : uint;
}

(* Contract address type, liveness, and field range macros *)

type item_cel_address = contract t_item_cel
let item_cel_live (c:item_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap

(* Field getters for contract Item_Cel *)

let item_cel_get_market (c:item_cel_address)
: StEth address
  (fun st -> c `item_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).item_cel_market)
= let item_cel_inst = get_contract c in
  item_cel_inst.item_cel_market

let item_cel_get_sellerId (c:item_cel_address)
: StEth address
  (fun st -> c `item_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).item_cel_sellerId)
= let item_cel_inst = get_contract c in
  item_cel_inst.item_cel_sellerId

let item_cel_get_price (c:item_cel_address)
: StEth uint
  (fun st -> c `item_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).item_cel_price)
= let item_cel_inst = get_contract c in
  item_cel_inst.item_cel_price

(* Field setters for contract Item_Cel *)

let item_cel_set_market (c:item_cel_address) (_market:address)
: StEth unit
  (fun st -> c `item_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    item_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with item_cel_market = _market }))
= let item_cel_inst = get_contract c in
  let item_cel_inst = { item_cel_inst with item_cel_market = _market } in
  set_contract c item_cel_inst

let item_cel_set_sellerId (c:item_cel_address) (_sellerId:address)
: StEth unit
  (fun st -> c `item_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    item_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with item_cel_sellerId = _sellerId }))
= let item_cel_inst = get_contract c in
  let item_cel_inst = { item_cel_inst with item_cel_sellerId = _sellerId } in
  set_contract c item_cel_inst

let item_cel_set_price (c:item_cel_address) (_price:uint)
: StEth unit
  (fun st -> c `item_cel_live` st.current
              /\ _price >= 0 /\ _price <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    item_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with item_cel_price = _price }))
= let item_cel_inst = get_contract c in
  let item_cel_inst = { item_cel_inst with item_cel_price = _price } in
  set_contract c item_cel_inst

let querySellerPost (_r:address) (old_sellerId:address)
= _r == old_sellerId

let queryPricePost (_r:uint) (old_price:uint)
= _r == old_price

let item_cel_constructor (self:item_cel_address) (sender:address) (value:uint) (now:uint) (_market:address) (_sellerId:address) (_price:uint)
: Eth1 unit
  (fun bst -> 
    item_cel_live self bst /\
    (let b = pure_get_balance_bst self bst in
    let cs = CM.sel self bst.cmap in
      (sender <> null)
      /\ (cs.item_cel_market == null)
      /\ (cs.item_cel_sellerId == null)
      /\ (cs.item_cel_price == 0)
    )
  )
  (fun bst -> False)
  (fun bst0 x bst1 ->
    item_cel_live self bst1 /\ (
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      (bst0.balances == bst1.balances)
      /\ (l0 == l1)
      /\ CM.modifies_addrs (Set.singleton self) bst0.cmap bst1.cmap
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let _ = item_cel_set_market self _market in
let cs = get_contract self in
let _ = item_cel_set_sellerId self _sellerId in
let cs = get_contract self in
let _ = item_cel_set_price self _price in
let cs = get_contract self in
()

let querySeller (self:item_cel_address) (sender:address) (value:uint) (now:uint)
: Eth1 address
  (fun bst ->
    item_cel_live self bst /\
    (sender <> null)
  )
  (fun bst -> False)
  (fun bst0 a bst1 ->
    item_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((querySellerPost a cs0.item_cel_sellerId))
      /\ (bst0.balances == bst1.balances)
      /\ CM.modifies_addrs (Set.singleton self) bst0.cmap bst1.cmap
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let a:address = null in
let cs = get_contract self in
let balance = get_balance self in
let a = cs.item_cel_sellerId in
let cs = get_contract self in
a

let queryPrice (self:item_cel_address) (sender:address) (value:uint) (now:uint)
: Eth1 uint
  (fun bst ->
    item_cel_live self bst /\
    (sender <> null)
  )
  (fun bst -> False)
  (fun bst0 r bst1 ->
    item_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
      ((queryPricePost r cs0.item_cel_price))
      /\ (bst0.balances == bst1.balances)
      /\ CM.modifies_addrs (Set.singleton self) bst0.cmap bst1.cmap
      /\ (cs0 == cs1)
      /\ (l0 == l1)
  ))
=
let r:uint = 0 in
let cs = get_contract self in
let balance = get_balance self in
let r = cs.item_cel_price in
let cs = get_contract self in
r