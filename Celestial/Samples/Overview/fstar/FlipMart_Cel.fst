(*Code generated by compiler*)

module FlipMart_Cel

open FStar.Celestial
open FStar.Celestial.Effect
module CM = FStar.Celestial.ContractsMap
open FStar.Mul
open Item_Cel
module M = FStar.Celestial.Map
module L = FStar.List.Tot
module A = FStar.Celestial.Array

assume val flipmart_cel_eNewItem : string
assume val flipmart_cel_eItemSold : string

noeq type t_flipmart_cel = {
  flipmart_cel_itemsToSell : (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)});
  flipmart_cel_sellerCredits : (m:(M.t address uint lt){M.def_of m == 0});
  flipmart_cel_sumCredits : uint;
}

(* Contract address type, liveness, and field range macros *)

type flipmart_cel_address = contract t_flipmart_cel
let flipmart_cel_live (c:flipmart_cel_address) (bst:bstate) =
  c `CM.live_in` bst.cmap
  /\ (let cs = CM.sel c bst.cmap in
    (forall (i:item_cel_address). M.contains cs.flipmart_cel_itemsToSell i ==> i `CM.live_in` bst.cmap /\ i <> c)
  )

(* Field getters for contract FlipMart_Cel *)

let flipmart_cel_get_itemsToSell (c:flipmart_cel_address)
: StEth (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)})
  (fun st -> c `flipmart_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).flipmart_cel_itemsToSell)
= let flipmart_cel_inst = get_contract c in
  flipmart_cel_inst.flipmart_cel_itemsToSell

let flipmart_cel_get_sellerCredits (c:flipmart_cel_address)
: StEth (m:(M.t address uint lt){M.def_of m == 0})
  (fun st -> c `flipmart_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).flipmart_cel_sellerCredits)
= let flipmart_cel_inst = get_contract c in
  flipmart_cel_inst.flipmart_cel_sellerCredits

let flipmart_cel_get_sumCredits (c:flipmart_cel_address)
: StEth uint
  (fun st -> c `flipmart_cel_live` st.current)
  (fun st0 r st1 ->
    st0 == st1 /\ r == (CM.sel c st0.current.cmap).flipmart_cel_sumCredits)
= let flipmart_cel_inst = get_contract c in
  flipmart_cel_inst.flipmart_cel_sumCredits

(* Field setters for contract FlipMart_Cel *)

let flipmart_cel_set_itemsToSell (c:flipmart_cel_address) (_itemsToSell:(m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}))
: StEth unit
  (fun st -> c `flipmart_cel_live` st.current
              /\ (forall (i:item_cel_address). M.contains _itemsToSell i ==> item_cel_live i st.current /\ i <> c))
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    flipmart_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with flipmart_cel_itemsToSell = _itemsToSell }))
= let flipmart_cel_inst = get_contract c in
  let flipmart_cel_inst = { flipmart_cel_inst with flipmart_cel_itemsToSell = _itemsToSell } in
  set_contract c flipmart_cel_inst

let flipmart_cel_set_sellerCredits (c:flipmart_cel_address) (_sellerCredits:(m:(M.t address uint lt){M.def_of m == 0}))
: StEth unit
  (fun st -> c `flipmart_cel_live` st.current)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    flipmart_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with flipmart_cel_sellerCredits = _sellerCredits }))
= let flipmart_cel_inst = get_contract c in
  let flipmart_cel_inst = { flipmart_cel_inst with flipmart_cel_sellerCredits = _sellerCredits } in
  set_contract c flipmart_cel_inst

let flipmart_cel_set_sumCredits (c:flipmart_cel_address) (_sumCredits:uint)
: StEth unit
  (fun st -> c `flipmart_cel_live` st.current
              /\ _sumCredits >= 0 /\ _sumCredits <= uint_max)
  (fun st0 _ st1 ->
    modifies_cmap_only (Set.singleton c) st0.current st1.current /\
    flipmart_cel_live c st1.current /\
    (let instance0 = CM.sel c st0.current.cmap in
     let instance1 = CM.sel c st1.current.cmap in
    instance1 == { instance0 with flipmart_cel_sumCredits = _sumCredits }))
= let flipmart_cel_inst = get_contract c in
  let flipmart_cel_inst = { flipmart_cel_inst with flipmart_cel_sumCredits = _sumCredits } in
  set_contract c flipmart_cel_inst

let balanceAndValuation (self:flipmart_cel_address) (bst:bstate{self `flipmart_cel_live` bst}) : Type0 =
  let flipmart_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    flipmart_cel_balance == cs.flipmart_cel_sumCredits

let balanceAndValuation2 (self:flipmart_cel_address) (bst:bstate{self `flipmart_cel_live` bst}) : Type0 =
  let flipmart_cel_balance = pure_get_balance_bst self bst in
  let cs = CM.sel self bst.cmap in
    cs.flipmart_cel_sumCredits == ((sum_mapping cs.flipmart_cel_sellerCredits))

let sellPost (_itemAddress:address) (old_ItemsToSell:tuple2 (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}) bstate{forall (k:item_cel_address). M.contains (fst old_ItemsToSell) k ==> k `CM.live_in` (snd old_ItemsToSell).cmap}) (new_ItemsToSell:tuple2 (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}) bstate{forall (k:item_cel_address). M.contains (fst new_ItemsToSell) k ==> k `CM.live_in` (snd new_ItemsToSell).cmap}) (old_log:log) (new_log:log) (_sender:address)
= ((((M.contains (fst new_ItemsToSell) _itemAddress))) /\ (~ (((M.contains (fst old_ItemsToSell) _itemAddress))))) /\ (new_log == ((mk_event _sender flipmart_cel_eNewItem _itemAddress)::old_log))

let sell (self:flipmart_cel_address) (sender:address) (value:uint) (now:uint) (sellingPrice:uint)
: Eth1 address
  (fun bst ->
    flipmart_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sender <> null)
      /\ (balanceAndValuation self bst)
      /\ (balanceAndValuation2 self bst)
  ))
  (fun bst -> False)
  (fun bst0 itemAddress bst1 ->
    flipmart_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (balanceAndValuation self bst1)
      /\ (balanceAndValuation2 self bst1)
      /\ ((sellPost itemAddress (cs0.flipmart_cel_itemsToSell, bst0) (cs1.flipmart_cel_itemsToSell, bst1) l0 l1 sender))
      /\ (bst0.balances == bst1.balances)
      /\ (cs0.flipmart_cel_sellerCredits == cs1.flipmart_cel_sellerCredits)
      /\ (cs0.flipmart_cel_sumCredits == cs1.flipmart_cel_sumCredits)
  ))
=
let itemAddress:address = null in
let cs = get_contract self in
let balance = get_balance self in
let x1 = ((
let contract_addr = create_contract ({item_cel_market = null; item_cel_sellerId = null; item_cel_price = 0; }) in 
let _ = item_cel_constructor contract_addr self 0 now self sender sellingPrice in
let _ = flipmart_cel_set_itemsToSell self (M.upd cs.flipmart_cel_itemsToSell contract_addr true) in contract_addr)) in
let itemAddress = x1 in
let cs = get_contract self in
let _ = emit sender flipmart_cel_eNewItem itemAddress in
let cs = get_contract self in
let balance = get_balance self in
itemAddress

let buyReverts (_itemAddress:address) (old_itemsToSell:tuple2 (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}) bstate{forall (k:item_cel_address). M.contains (fst old_itemsToSell) k ==> k `CM.live_in` (snd old_itemsToSell).cmap}) (old_sellerCredits:(m:(M.t address uint lt){M.def_of m == 0})) (_value:uint) (old_sumCredits:uint)
= ((~ (((M.contains (fst old_itemsToSell) _itemAddress)))) \/ ((_value =!= ((CM.sel _itemAddress (snd old_itemsToSell).cmap).item_cel_price)))) \/ (((_value + old_sumCredits) > uint_max))

let buyPost (_itemAddress:address) (old_ItemsToSell:tuple2 (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}) bstate{forall (k:item_cel_address). M.contains (fst old_ItemsToSell) k ==> k `CM.live_in` (snd old_ItemsToSell).cmap}) (new_ItemsToSell:tuple2 (m:(M.t item_cel_address bool lt){M.def_of m == false /\ ~ (M.contains m null)}) bstate{forall (k:item_cel_address). M.contains (fst new_ItemsToSell) k ==> k `CM.live_in` (snd new_ItemsToSell).cmap}) (old_sellerCredits:(m:(M.t address uint lt){M.def_of m == 0})) (new_sellerCredits:(m:(M.t address uint lt){M.def_of m == 0})) (_buyer:address) (old_log:log) (new_log:log)
= ((((((M.contains (fst old_ItemsToSell) _itemAddress))) /\ (~ (((M.contains (fst new_ItemsToSell) _itemAddress))))) /\ (((M.sel old_sellerCredits ((CM.sel _itemAddress (snd old_ItemsToSell).cmap).item_cel_sellerId)) + ((CM.sel _itemAddress (snd old_ItemsToSell).cmap).item_cel_price)) <= uint_max)) /\ (M.equal new_sellerCredits (
                          let x1 = (old_sellerCredits) in
                          let x2 = ((CM.sel _itemAddress (snd old_ItemsToSell).cmap).item_cel_sellerId) in
                          let x3 = ((M.sel old_sellerCredits ((CM.sel _itemAddress (snd old_ItemsToSell).cmap).item_cel_sellerId)) + ((CM.sel _itemAddress (snd old_ItemsToSell).cmap).item_cel_price)) in
                          let x1 = (M.upd x1 x2 x3) in
                          x1))) /\ (new_log == ((mk_event _buyer flipmart_cel_eItemSold _itemAddress)::old_log))

let buy (self:flipmart_cel_address) (sender:address) (value:uint) (now:uint) (itemAddress:address)
: Eth1 unit
  (fun bst ->
    flipmart_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sender <> null)
      /\ (balanceAndValuation self bst)
      /\ (balanceAndValuation2 self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    ((buyReverts itemAddress (cs.flipmart_cel_itemsToSell, bst) cs.flipmart_cel_sellerCredits value cs.flipmart_cel_sumCredits))
  )
  (fun bst0 x bst1 ->
    flipmart_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (balanceAndValuation self bst1)
      /\ (balanceAndValuation2 self bst1)
      /\ ((buyPost itemAddress (cs0.flipmart_cel_itemsToSell, bst0) (cs1.flipmart_cel_itemsToSell, bst1) cs0.flipmart_cel_sellerCredits cs1.flipmart_cel_sellerCredits sender l0 l1))
  ))
=
let b = get_balance self in
let _ = set_balance self (
          if (b + value > uint_max) then (b + value - uint_max)
          else (b + value)) in
let cs = get_contract self in
let balance = get_balance self in
let item:item_cel_address = (
if M.contains cs.flipmart_cel_itemsToSell itemAddress then itemAddress else null) in
let x1 = (item = null) in
let _ = (if x1 then begin
revert "<ErrorLog>: The selected item does not exist or has been sold already";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let price:uint = (0) in
let bst = (get ()).current in
let x1 = queryPrice item self 0 now in
let price = x1 in
let balance = get_balance self in
let _ = (if (value <> price) then begin
revert "<ErrorLog>: Incorrect price";
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
let seller:address = (null) in
let bst = (get ()).current in
let x1 = querySeller item self 0 now in
let seller = x1 in
let balance = get_balance self in
let x1 = ((if cs.flipmart_cel_sumCredits <= uint_max - price then (cs.flipmart_cel_sumCredits + price) else revert "Overflow error")) in
let _ = flipmart_cel_set_sumCredits self x1 in
let cs = get_contract self in
let x1 = (((_add (M.sel cs.flipmart_cel_sellerCredits seller) price))) in
let sellerCredits = cs.flipmart_cel_sellerCredits in
let _ = flipmart_cel_set_sellerCredits self (M.upd sellerCredits seller x1) in
let cs = get_contract self in
let _ = flipmart_cel_set_itemsToSell self (M.delete cs.flipmart_cel_itemsToSell itemAddress) in
let cs = get_contract self in
let _ = emit sender flipmart_cel_eItemSold itemAddress in
let cs = get_contract self in
let balance = get_balance self in
()

let withdraw (self:flipmart_cel_address) (sender:address) (value:uint) (now:uint) (amount:uint)
: Eth1 unit
  (fun bst ->
    flipmart_cel_live self bst /\ (
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
      (sender <> null)
      /\ (balanceAndValuation self bst)
      /\ (balanceAndValuation2 self bst)
  ))
  (fun bst ->
    let cs = CM.sel self bst.cmap in
    let b = pure_get_balance_bst self bst in
    let l = bst.log in
    (((M.sel cs.flipmart_cel_sellerCredits sender) < amount) \/ (b < amount))
  )
  (fun bst0 x bst1 ->
    flipmart_cel_live self bst1 /\ (
    let cs0 = CM.sel self bst0.cmap in
    let cs1 = CM.sel self bst1.cmap in
    let b0 = pure_get_balance_bst self bst0 in
    let b1 = pure_get_balance_bst self bst1 in
    let l0 = bst0.log in
    let l1 = bst1.log in
    (balanceAndValuation self bst1)
      /\ (balanceAndValuation2 self bst1)
      /\ (((l1 == ((mk_event sender eTransfer amount)::l0)) /\ (if (b1 < b0) then
  (M.equal cs1.flipmart_cel_sellerCredits (
                                    let x1 = (cs0.flipmart_cel_sellerCredits) in
                                    let x2 = (sender) in
                                    let x3 = ((M.sel cs0.flipmart_cel_sellerCredits sender) - amount) in
                                    let x1 = (M.upd x1 x2 x3) in
                                    x1))
else
 ((b1 == b0) /\ (M.equal cs1.flipmart_cel_sellerCredits cs0.flipmart_cel_sellerCredits))
)))
      /\ (b1 <= b0)
  ))
=
let cs = get_contract self in
let balance = get_balance self in
let bal:uint = (balance) in
let x1 = ((M.sel cs.flipmart_cel_sellerCredits sender) >= amount) in
let _ = (if x1 then begin
let _ = send self sender amount in
let cs = get_contract self in
let balance = get_balance self in
let _ = (if (balance < bal) then begin
let x1 = ((_sub (M.sel cs.flipmart_cel_sellerCredits sender) amount)) in
let sellerCredits = cs.flipmart_cel_sellerCredits in
let _ = flipmart_cel_set_sellerCredits self (M.upd sellerCredits sender x1) in
let cs = get_contract self in
let _ = flipmart_cel_set_sumCredits self (_sub cs.flipmart_cel_sumCredits amount) in
let cs = get_contract self in
() end
else ()) in
let cs = get_contract self in
let balance = get_balance self in
() end
else begin
revert " Insufficient balance";
() end) in
let cs = get_contract self in
let balance = get_contract self in
()