// SPDX-License-Identifier: MIT
/* Code generated by compiler */

pragma solidity >=0.5.0 <0.7.0;

import {Safe_Arith} from "./Safe_Arith.sol";

contract Item_Cel
{
    receive() external payable {}
    bool _lock_ = false;

    modifier isUnlocked () {
        require (_lock_ == false);
        _;
    }

    address market;
    address sellerId;
    uint price;

    constructor (address _market, address _sellerId, uint _price) public {
        market = _market;
        sellerId = _sellerId;
        price = _price;
        return;
    }

    function querySeller () public isUnlocked returns (address a) {
        a = sellerId;
        return a;
    }

    function queryPrice () public isUnlocked returns (uint r) {
        r = price;
        return r;
    }
}

contract FlipMart_Cel
{
    receive() external payable {}
    bool _lock_ = false;

    modifier isUnlocked () {
        require (_lock_ == false);
        _;
    }

    event eNewItem(address indexed, address);
    event eItemSold(address indexed, uint);
    mapping (Item_Cel => bool) itemsToSell;

    function get_from_itemsToSell (Item_Cel i) private returns (Item_Cel) {
        if (itemsToSell[i]) return i;
    }

    function add_to_itemsToSell (Item_Cel i) private returns (Item_Cel) {
        itemsToSell[i] = true;
        return i;
    }
    mapping (address => uint) sellerCredits;
    uint sumCredits;

    function sell (uint sellingPrice) public isUnlocked returns (address itemAddress) {
        itemAddress = address(add_to_itemsToSell(new Item_Cel(address(this), msg.sender, sellingPrice)));
        emit eNewItem(msg.sender, itemAddress);
        return itemAddress;
    }

    function buy (address itemAddress) public isUnlocked payable {
        Item_Cel item = get_from_itemsToSell(Item_Cel(payable(itemAddress)));
        if (item == address(0))
        {
            revert ("<ErrorLog>: The selected item does not exist or has been sold already");
        }
        uint price;
        item.queryPrice();
        if (msg.value != price)
        {
            revert ("<ErrorLog>: Incorrect price");
        }
        address seller;
        item.querySeller();
        sumCredits = Safe_Arith.safe_add(sumCredits, price);
        sellerCredits[seller] = (sellerCredits[seller] + price);
        emit eItemSold(msg.sender, itemAddress);
        return;
    }

    function withdraw (uint amount) public isUnlocked {
        uint bal = address(this).balance;
        if (sellerCredits[msg.sender] >= amount)
        {
            if (address(this).balance < amount) revert ("Insufficient balance");
            msg.sender.call{value: (amount), gas: 2300}("");
            if (address(this).balance < bal)
            {
                sellerCredits[msg.sender] = sellerCredits[msg.sender] - amount;
                sumCredits = sumCredits - amount;
            }
        }
        else
        {
            revert (" Insufficient balance");
        }
        return;
    }
}