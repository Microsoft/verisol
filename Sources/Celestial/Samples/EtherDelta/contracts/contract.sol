// SPDX-License-Identifier: MIT
/* Code generated by compiler */

pragma solidity >=0.5.0 <0.7.0;

import {Safe_Arith} from "./Safe_Arith.sol";

contract EtherDelta_Cel
{
    receive() external payable {}
    event Deposit(address, address, uint, uint);
    event Withdraw(address, address, uint, uint);
    address admin;
    address feeAccount;
    uint feeMake;
    uint feeTake;
    uint feeRebate;
    mapping (uint => mapping (address => uint)) tokens;
    bool tokenTxStatus;
    uint totalBalance;
    bool _lock_;

    constructor (address admin_, address feeAccount_, uint feeMake_, uint feeTake_, uint feeRebate_) public {
        admin = admin_;
        feeAccount = feeAccount_;
        feeMake = feeMake_;
        feeTake = feeTake_;
        feeRebate = feeRebate_;
        return;
    }

    function changeAdmin (address admin_) public isUnlocked {
        if (msg.sender != admin)
        {
            revert ("invalid");
        }
        admin = admin_;
        return;
    }

    function changeFeeAccount (address feeAccount_) public isUnlocked {
        if (msg.sender != admin)
        {
            revert ("invalid");
        }
        feeAccount = feeAccount_;
        return;
    }

    function changeFeeMake (uint feeMake_) public isUnlocked {
        if (msg.sender != admin || feeMake_ > feeMake)
        {
            revert ("invalid");
        }
        feeMake = feeMake_;
        return;
    }

    function changeFeeTake (uint feeTake_) public isUnlocked {
        if (msg.sender != admin || feeTake_ > feeTake || feeTake_ < feeRebate)
        {
            revert ("invalid");
        }
        feeTake = feeTake_;
        return;
    }

    function changeFeeRebate (uint feeRebate_) public isUnlocked {
        if (msg.sender != admin || feeRebate_ < feeRebate || feeRebate_ > feeTake)
        {
            revert ("invalid");
        }
        feeRebate = feeRebate_;
        return;
    }

    function deposit () public isUnlocked payable {
        totalBalance = Safe_Arith.safe_add(totalBalance, msg.value);
        tokens[0][msg.sender] = tokens[0][msg.sender] + msg.value;
        emit Deposit(address(0), msg.sender, msg.value, tokens[0][msg.sender]);
        return;
    }

    function withdraw (uint amount) public isUnlocked {
        if (tokens[0][msg.sender] < amount)
        {
            revert ("Insufficient balance");
        }
        uint b = address(this).balance;
        if (address(this).balance < amount) revert ("Insufficient balance");
        msg.sender.call{value: (amount), gas: 2300}("");
        if (b != address(this).balance)
        {
            tokens[0][msg.sender] = tokens[0][msg.sender] - amount;
            totalBalance = totalBalance - amount;
            emit Withdraw(address(0), msg.sender, amount, tokens[0][msg.sender]);
        }
        return;
    }

    function depositToken (uint tokenId, address token, uint amount) public isUnlocked {
        if (tokenId == 0 || amount > (~uint256(0)) - tokens[tokenId][msg.sender])
        {
            revert ("Invalid token type or overflow");
        }
        _lock_ = true;
        (tokenTxStatus, ) = token.call(abi.encodeWithSignature("transferFrom(address,address,uint)", msg.sender, address(this), amount));
        _lock_ = false;
        if (totalBalance > address(this).balance)
        {
            revert ("Unexpected Ether transferred to self");
        }
        totalBalance = address(this).balance;
        if (tokenTxStatus == true)
        {
            tokens[tokenId][msg.sender] = tokens[tokenId][msg.sender] + amount;
            emit Deposit(token, msg.sender, amount, tokens[tokenId][msg.sender]);
        }
        return;
    }

    function withdrawToken (uint tokenId, address token, uint amount) public isUnlocked {
        if (tokenId == 0 || tokens[tokenId][msg.sender] < amount)
        {
            revert ("Invalid token type or overflow");
        }
        _lock_ = true;
        (tokenTxStatus, ) = token.call(abi.encodeWithSignature("transfer(address,uint)", msg.sender, amount));
        _lock_ = false;
        if (totalBalance > address(this).balance)
        {
            revert ("Unexpected Ether transferred to self");
        }
        totalBalance = address(this).balance;
        if (tokenTxStatus == true)
        {
            tokens[tokenId][msg.sender] = tokens[tokenId][msg.sender] - amount;
            emit Withdraw(msg.sender, token, amount, tokens[tokenId][msg.sender]);
        }
        return;
    }
}