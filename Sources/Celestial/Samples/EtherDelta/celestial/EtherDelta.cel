contract EtherDelta_Cel
{
    address admin;      //the admin address
    address feeAccount; //the account that will receive fees
    uint feeMake;       //percentage times (1 ether)
    uint feeTake;       //percentage times (1 ether)
    uint feeRebate;     //percentage times (1 ether)
    mapping (uint => mapping (address => uint)) tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether)
    event Deposit(address, address, uint, uint);
    event Withdraw(address, address, uint, uint);

    bool tokenTxStatus;
    uint totalBalance;
    bool _lock_;

    invariant eth_balances2 {
        balance == totalBalance
    }

    invariant eth_balances {
        totalBalance >= sum_mapping(tokens[0])
    }

    constructor (address admin_, address feeAccount_, uint feeMake_, uint feeTake_, uint feeRebate_) 
        pre (balance == 0)
    {
        admin = admin_;
        feeAccount = feeAccount_;
        feeMake = feeMake_;
        feeTake = feeTake_;
        feeRebate = feeRebate_;
        return;
    }

    function changeAdmin (address admin_) public
        post (new(admin) == admin_)
        tx_reverts (sender != admin)
        r_reverts _lock_
        modifies [admin]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (sender != admin) 
        {
            revert("invalid");
        }
        admin = admin_;
        return;
    }

    function changeFeeAccount (address feeAccount_) public
        tx_reverts (sender != admin)
        r_reverts _lock_
        modifies [feeAccount]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (sender != admin) 
        {
            revert("invalid");
        }
        feeAccount = feeAccount_;
        return;
    }

    function changeFeeMake (uint feeMake_) public
        post new(feeMake) == feeMake_
        tx_reverts (sender != admin || feeMake_ > feeMake) 
        r_reverts _lock_
        modifies [feeMake]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (sender != admin || feeMake_ > feeMake) 
        {
            revert("invalid");
        }

        feeMake = feeMake_;
        return;
    }

    function changeFeeTake (uint feeTake_) public
        post new(feeTake) == feeTake_
        tx_reverts (sender != admin || feeTake_ > feeTake || feeTake_ < feeRebate) 
        r_reverts _lock_
        modifies [feeTake]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (sender != admin || feeTake_ > feeTake || feeTake_ < feeRebate) {
            revert("invalid");
        }

        feeTake = feeTake_;
        return;
    }

    function changeFeeRebate (uint feeRebate_) public
        post new(feeRebate) == feeRebate_
        tx_reverts (sender != admin || feeRebate_ < feeRebate || feeRebate_ > feeTake)
        r_reverts _lock_
        modifies [feeRebate]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (sender != admin || feeRebate_ < feeRebate || feeRebate_ > feeTake) 
        {
            revert("invalid");
        }
        feeRebate = feeRebate_;
        return;
    }

    function deposit () public
        post (new(tokens) == tokens[0 => tokens[0][sender => (tokens[0][sender] + value)]])
             && (new(totalBalance) == totalBalance + value)
        credit
        tx_reverts (totalBalance + value > uint_max)
        r_reverts _lock_
        modifies [tokens, totalBalance, log]
    {
        if (_lock_) revert ("Reentrancy detected");
        totalBalance = safe_add(totalBalance, value);
        tokens[0][sender] = tokens[0][sender] + value;
        emit Deposit (null, sender, value, tokens[0][sender]);
        return;
    }

    function withdraw (uint amount) public
        post (balance != new(balance) ==> (new(tokens) == tokens[0 => tokens[0][sender => tokens[0][sender] - amount]])
             && new(log) == (Withdraw, null, sender, amount, new(tokens)[0][sender])::(sender, eTransfer, amount)::log)
        debit
        tx_reverts (tokens[0][sender] < amount) 
        r_reverts _lock_
    {
        if (_lock_) revert ("Reentrancy detected");
        if (tokens[0][sender] < amount) 
        {
            revert ("Insufficient balance");
        }

        uint b = balance;
        send (sender, eTransfer, amount);
        if (b != balance)
        {
            tokens[0][sender] = tokens[0][sender] - amount;
            totalBalance = totalBalance - amount;
            emit Withdraw (null, sender, amount, tokens[0][sender]);
        }
        return;
    }

    function depositToken (uint tokenId, address token, uint amount) public
        post new(tokenTxStatus) ==>
                 new(tokens) == tokens[tokenId => tokens[tokenId][sender => tokens[tokenId][sender] + amount]]
        tx_reverts tokenId == 0 || tokens[tokenId][sender] + amount > uint_max
        r_reverts _lock_
        modifies [tokenTxStatus, tokens, totalBalance, balance, log, _lock_]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (tokenId == 0 || amount > uint_max - tokens[tokenId][sender])
        {
            revert ("Invalid token type or overflow");
        }

        _lock_ = true;
        tokenTxStatus = token.call("transferFrom(address,address,uint)", sender, address(this), amount);
        _lock_ = false;
        if (totalBalance > balance) {
            revert ("Unexpected Ether transferred to self");
        }
        totalBalance = balance;
        
        if (tokenTxStatus == true) {
            tokens[tokenId][sender] = tokens[tokenId][sender] + amount;
            emit Deposit (token, sender, amount, tokens[tokenId][sender]);
        }
        return;
    }

    function withdrawToken (uint tokenId, address token, uint amount) 
        post new(tokenTxStatus) ==> (new(tokens) == tokens[tokenId => tokens[tokenId][sender => tokens[tokenId][sender] - amount]])
        tx_reverts tokenId == 0 || tokens[tokenId][sender] < amount
        r_reverts _lock_
        modifies[tokenTxStatus, tokens, totalBalance, balance, log, _lock_]
    {
        if (_lock_) revert ("Reentrancy detected");
        if (tokenId == 0 || tokens[tokenId][sender] < amount)
        {
            revert ("Invalid token type or overflow");
        }

        _lock_ = true;
        tokenTxStatus = token.call("transfer(address,uint)", sender, amount);
        _lock_ = false;
        if (totalBalance > balance) {
            revert ("Unexpected Ether transferred to self");
        }
        totalBalance = balance;

        if (tokenTxStatus == true) {
            tokens[tokenId][sender] = tokens[tokenId][sender] - amount;
            emit Withdraw (sender, token, amount, tokens[tokenId][sender]);
        }
        return;
    }
}