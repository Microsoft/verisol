// SPDX-License-Identifier: MIT
/* Code generated by compiler */

pragma solidity >=0.5.0 <0.7.0;


contract MarketPlace_Cel
{
    receive() external payable {}
    bool _lock_ = false;

    modifier isUnlocked () {
        require (_lock_ == false);
        _;
    }

    enum state
    {
        marketPlace_Active, marketPlace_OfferPlaced, marketPlace_NotionalAccept, marketPlace_BuyerAccept, marketPlace_SellerAccept, marketPlace_Accept
    }
    event eMakeOffer(address indexed, uint);
    event eAcceptOffer(address indexed, uint);
    address seller;
    address buyer;
    uint sellingPrice;
    uint buyingPrice;
    state contractCurrentState;

    constructor (address _seller, address _buyer) public {
        seller = _seller;
        buyer = _buyer;
        contractCurrentState = state.marketPlace_Active;
        return;
    }

    function makeOffer (uint _sellingPrice) public isUnlocked {
        if (msg.sender != seller)
        {
            revert ("");
        }
        if (contractCurrentState != state.marketPlace_Active)
        {
            revert ("<makeOffer> function invoked in invalid state");
        }
        sellingPrice = _sellingPrice;
        contractCurrentState = state.marketPlace_OfferPlaced;
        emit eMakeOffer(buyer, sellingPrice);
        return;
    }

    function modifyOffer (bool _increase, uint _change) public isUnlocked {
        if (msg.sender != seller)
        {
            revert ("");
        }
        if (! (contractCurrentState == state.marketPlace_OfferPlaced && msg.sender == seller))
        {
            revert ("<modifyOffer> function invoked in invalid state");
        }
        if (_increase && sellingPrice <= (~uint256(0)) - _change)
        {
            sellingPrice = sellingPrice + _change;
        }
        else
        {
            if (sellingPrice >= _change)
            {
                sellingPrice = sellingPrice - _change;
            }
        }
        return;
    }

    function rejectOffer () public isUnlocked {
        if (msg.sender != buyer)
        {
            revert ("");
        }
        if (! (contractCurrentState == state.marketPlace_OfferPlaced && msg.sender == buyer))
        {
            revert ("<rejectOffer> function invoked in invalid state");
        }
        contractCurrentState = state.marketPlace_Active;
        return;
    }

    function acceptOffer () public isUnlocked payable {
        if (contractCurrentState != state.marketPlace_OfferPlaced || msg.sender != buyer)
        {
            revert ("<acceptOffer> function invoked in invalid state");
        }
        if (msg.value >= sellingPrice)
        {
            buyingPrice = msg.value;
            emit eAcceptOffer(seller, buyingPrice);
            contractCurrentState = state.marketPlace_NotionalAccept;
        }
        return;
    }

    function accept () public isUnlocked {
        if (! (contractCurrentState == state.marketPlace_NotionalAccept || contractCurrentState == state.marketPlace_BuyerAccept || contractCurrentState == state.marketPlace_SellerAccept))
        {
            revert ("<accept> function invoked in invalid state");
        }
        if (contractCurrentState == state.marketPlace_NotionalAccept && msg.sender == buyer)
        {
            contractCurrentState = state.marketPlace_BuyerAccept;
        }
        else
        if (contractCurrentState == state.marketPlace_NotionalAccept && msg.sender == seller)
        {
            contractCurrentState = state.marketPlace_SellerAccept;
        }
        else
        if (contractCurrentState == state.marketPlace_BuyerAccept && msg.sender == seller)
        {
            contractCurrentState = state.marketPlace_Accept;
        }
        else
        if (contractCurrentState == state.marketPlace_SellerAccept && msg.sender == buyer)
        {
            contractCurrentState = state.marketPlace_Accept;
        }
        return;
    }

    function withdraw () public isUnlocked {
        if (msg.sender != seller)
        {
            revert ("");
        }
        if (! (contractCurrentState == state.marketPlace_Accept && msg.sender == seller))
        {
            revert ("<withdraw> function invoked in invalid state");
        }
        if (address(this).balance < buyingPrice) revert ("Insufficient balance");
        seller.call{value: (buyingPrice), gas: 2300}("");
        return;
    }
}