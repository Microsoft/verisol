// SPDX-License-Identifier: MIT
/* Code generated by compiler */

pragma solidity >=0.5.0 <0.7.0;

import {Safe_Arith} from "./Safe_Arith.sol";

contract SimpleAuction_Cel
{
    receive() external payable {}
    bool _lock_ = false;

    modifier isUnlocked () {
        require (_lock_ == false);
        _;
    }

    event HighestBidIncreased(address, uint);
    event AuctionEnded(address, uint);
    address beneficiary;
    uint auctionEndTime;
    address highestBidder;
    uint highestBid;
    mapping (address => uint) pendingReturns;
    bool ended;
    uint totalReturns;

    constructor (uint _biddingTime, address _beneficiary) public {
        beneficiary = _beneficiary;
        auctionEndTime = Safe_Arith.safe_add(block.timestamp, _biddingTime);
        return;
    }

    function bid () public isUnlocked payable {
        if (block.timestamp > auctionEndTime)
        revert ("Auction already ended.");
        if (msg.value <= highestBid)
        revert ("There already is a higher bid.");
        totalReturns = Safe_Arith.safe_add(totalReturns, msg.value);
        if (highestBid != 0)
        pendingReturns[highestBidder] = Safe_Arith.safe_add(pendingReturns[highestBidder], highestBid);
        highestBidder = msg.sender;
        highestBid = msg.value;
        emit HighestBidIncreased(msg.sender, msg.value);
        return;
    }

    function withdraw () public isUnlocked returns (bool) {
        uint bal = address(this).balance;
        uint amount = pendingReturns[msg.sender];
        if (amount > 0)
        {
            if (address(this).balance < amount) revert ("Insufficient balance");
            msg.sender.call{value: (amount), gas: 2300}("");
            if (address(this).balance < bal)
            {
                pendingReturns[msg.sender] = 0;
                totalReturns = totalReturns - amount;
            }
        }
        return true;
    }

    function auctionEnd () public isUnlocked {
        if (block.timestamp < auctionEndTime)
        revert ("Auction not yet ended.");
        if (ended)
        revert ("auctionEnd has already been called.");
        ended = true;
        emit AuctionEnded(highestBidder, highestBid);
        uint bal = address(this).balance;
        if (address(this).balance < highestBid) revert ("Insufficient balance");
        beneficiary.call{value: (highestBid), gas: 2300}("");
        if (address(this).balance < bal)
        totalReturns = totalReturns - highestBid;
        return;
    }
}