contract SimpleAuction_Cel {
    address beneficiary;
    uint auctionEndTime;
    address highestBidder;
    uint highestBid;
    mapping (address => uint) pendingReturns;
    bool ended;

    event eHighestBidIncreased (uint);
    event eAuctionEnded (uint);

    uint totalReturns;

    invariant inv1 
    {
        totalReturns == balance
    }

    invariant inv
    {
        !ended ==> (balance == sum_mapping (pendingReturns) + highestBid)
    }

    // The constructor assumes that balance of the current contract = 0
    // Theoretically, it may be greater than 0 if Ether is sent to this address
    //   before it was deployed, but it is not probable.
    constructor (uint _biddingTime, address _beneficiary) public
        pre balance == 0
        tx_reverts now + _biddingTime > uint_max
    {
        beneficiary = _beneficiary;
        auctionEndTime = safe_add (now, _biddingTime);
        return;
    }

    spec bidPost (
        uint old_highestBid, uint new_highestBid,
        address old_highestBidder, address new_highestBidder,
        address _sender, uint _value,
        mapping (address => uint) old_pendingReturns,
        mapping (address => uint) new_pendingReturns) 
    {
        old_pendingReturns[old_highestBidder] + old_highestBid <= uint_max
        && ite (
            old_highestBid != 0,
            new_pendingReturns == old_pendingReturns[old_highestBidder => old_pendingReturns[old_highestBidder] + old_highestBid],
            new_pendingReturns == old_pendingReturns
        )
        && new_highestBidder == _sender
        && new_highestBid == _value
    }

    function bid () public
        credit
        post bidPost (highestBid, new(highestBid), highestBidder, new(highestBidder), sender, value, pendingReturns, new(pendingReturns))
        tx_reverts now > auctionEndTime
                   || value <= highestBid
                   || pendingReturns[highestBidder] + highestBid > uint_max
                   || totalReturns + value > uint_max
        modifies [totalReturns, highestBidder, highestBid, log, pendingReturns]
    {
        if (now > auctionEndTime)
            revert ("Auction already ended.");

        if (value <= highestBid)
            revert ("There already is a higher bid.");

        totalReturns = safe_add (totalReturns, value);

        if (highestBid != 0)
            pendingReturns[highestBidder] = safe_add (pendingReturns[highestBidder], highestBid);

        highestBidder = sender;
        highestBid = value;
        send (sender, eHighestBidIncreased, value);
        return;
    }

    spec withdrawPost(
        address _sender, eventlog old_log, eventlog new_log,
        mapping (address => uint) old_pendingReturns,
        mapping (address => uint) new_pendingReturns,
        uint old_balance, uint new_balance)
    {
        ite (
            old_pendingReturns[_sender] > 0,
            new_log == (_sender, eTransfer, old_pendingReturns[_sender])::old_log
            && ite 
            (
                new_balance < old_balance,
                new_pendingReturns == old_pendingReturns[_sender => 0],
                new_pendingReturns == old_pendingReturns
            ),
            new_pendingReturns == old_pendingReturns
        )
    }

    function withdraw () public
        debit
        post withdrawPost (sender, log, new(log), pendingReturns, new(pendingReturns), balance, new(balance))
        tx_reverts balance < pendingReturns[sender]
        modifies [pendingReturns, totalReturns]
        returns (bool)
    {
        uint bal = balance;
        uint amount = pendingReturns[sender];
        if (amount > 0) 
        {
            send (sender, eTransfer, amount);

            if (balance < bal) 
            {
                pendingReturns[sender] = 0;
                totalReturns = totalReturns - amount;
            }
        }
        return true;
    }

    spec auctionEndPost (
        bool new_ended, eventlog old_log, eventlog new_log,
        address old_beneficiary, uint old_highestBid, address old_highestBidder)
    {
        new_ended && (new_log == (old_beneficiary, eTransfer, old_highestBid)::(old_highestBidder, eAuctionEnded, old_highestBid)::old_log)
    }

    function auctionEnd () public 
        post auctionEndPost (new(ended), log, new(log), beneficiary, highestBid, highestBidder)
        debit
        tx_reverts now < auctionEndTime || ended || balance < highestBid
        modifies [totalReturns, ended]
    {
        if (now < auctionEndTime)
            revert ("Auction not yet ended.");
        if (ended)
            revert ("auctionEnd has already been called.");

        ended = true;
        send (highestBidder, eAuctionEnded, highestBid);

        uint bal = balance;
        
        send (beneficiary, eTransfer, highestBid);
        
        if (balance < bal)
            totalReturns = totalReturns - highestBid;

        return;
    }
}